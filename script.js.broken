// å…¨å±€å˜é‡
let currentUser = null;
let users = [];
let systemSettings = {};
let dataSourceConfig = {
    currentSource: 'local',
    localPath: '',
    remoteUrl: '',
    lastSync: null
};
let db = null;

// æ•°æ®åº“é…ç½®
let dbConfig = {
    type: 'sqlite', // 'sqlite', 'api', 'indexeddb'
    apiBase: 'http://localhost:3000/api',
    localDbName: 'priceSystemDB',
    version: 1
};

// åˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, initializing all features...');
    
    try {
        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨
        initializeEventListeners();
        
        // åˆå§‹åŒ–ç³»ç»Ÿ
        initializeSystem();
        loadData();
        showLoginPage();
        
        // æµ‹è¯•localStorageæ˜¯å¦å·¥ä½œ
        console.log('Testing localStorage...');
        try {
            localStorage.setItem('test', 'test');
            const testValue = localStorage.getItem('test');
            console.log('localStorage test:', testValue === 'test' ? 'PASSED' : 'FAILED');
            localStorage.removeItem('test');
        } catch (e) {
            console.error('localStorage test failed:', e);
        }
        
        // åŠ è½½é…ç½®åˆ°ç•Œé¢
        if (localStorage.getItem('dbConfig')) {
            const savedDbConfig = JSON.parse(localStorage.getItem('dbConfig'));
            const dbTypeElement = safeGetElement('dbType');
            if (dbTypeElement) {
                dbTypeElement.value = savedDbConfig.type;
            }
            
            const apiBaseElement = safeGetElement('apiBaseUrl');
            if (apiBaseElement && savedDbConfig.apiBase) {
                apiBaseElement.value = savedDbConfig.apiBase;
            }
            toggleDatabaseConfig();
        }
        
        if (localStorage.getItem('dataSourceConfig')) {
            const savedDataSourceConfig = JSON.parse(localStorage.getItem('dataSourceConfig'));
            const dataSourceTypeElement = safeGetElement('dataSourceType');
            if (dataSourceTypeElement) {
                dataSourceTypeElement.value = savedDataSourceConfig.currentSource;
            }
            
            // æ ¹æ®ä¿å­˜çš„é…ç½®æ˜¾ç¤ºå¯¹åº”åŒºåŸŸ
            toggleDataSourceConfig();
            
            // å¦‚æœæœ‰ä¿å­˜çš„è¿œç¨‹URLï¼Œè®¾ç½®åˆ°è¾“å…¥æ¡†
            const remoteUrlElement = safeGetElement('remoteUrl');
            if (remoteUrlElement && savedDataSourceConfig.remoteUrl) {
                remoteUrlElement.value = savedDataSourceConfig.remoteUrl;
            }
        }
        
        // å»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿DOMå®Œå…¨åŠ è½½
        setTimeout(() => {
            setDefaultDates();
        }, 100);
        
        // åˆå§‹åŒ–æ•°æ®åº“çŠ¶æ€
        setTimeout(refreshDatabaseStatus, 1000);
        
        console.log('All features initialized successfully');
        
    } catch (error) {
        console.error('Error during initialization:', error);
    }
});

// è®¾ç½®é»˜è®¤æ—¥æœŸ
function setDefaultDates() {
    const today = new Date();
    const validUntil = new Date();
    validUntil.setDate(today.getDate() + 30); // 30å¤©åæœ‰æ•ˆ
    
    const todayStr = today.toISOString().split('T')[0];
    const validUntilStr = validUntil.toISOString().split('T')[0];
    
    const quotationDateInput = document.getElementById('quotationDate');
    const validUntilInput = document.getElementById('validUntil');
    
    if (quotationDateInput) {
        quotationDateInput.value = todayStr;
    }
    if (validUntilInput) {
        validUntilInput.value = validUntilStr;
    }
}

// å®‰å…¨DOMè®¿é—®å‡½æ•°
function safeGetElement(id, fallback = null) {
    try {
        const element = document.getElementById(id);
        if (!element) {
            console.warn(`Element with id '${id}' not found`);
            return fallback;
        }
        return element;
    } catch (error) {
        console.error(`Error getting element '${id}':`, error);
        return fallback;
    }
}

// åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨
function initializeEventListeners() {
    try {
        const taxRateElement = safeGetElement('taxRate');
        const shippingFeeElement = safeGetElement('shippingFee');
        
        if (taxRateElement) {
            taxRateElement.addEventListener('input', updateQuotationSummary);
            console.log('Tax rate listener initialized');
        } else {
            console.warn('Tax rate element not found');
        }
        
        if (shippingFeeElement) {
            shippingFeeElement.addEventListener('input', updateQuotationSummary);
            console.log('Shipping fee listener initialized');
        } else {
            console.warn('Shipping fee element not found');
        }
        
    } catch (error) {
        console.error('Error initializing event listeners:', error);
    }
}

// ç³»ç»Ÿåˆå§‹åŒ–
function initializeSystem() {
    try {
        console.log('Initializing system...');
        
        // æ¸…ç†æ—§çš„localStorageæ•°æ®
        clearOldData();
        
        // åˆå§‹åŒ–æ•°æ®åº“
        initializeDatabase();
        
        // åŠ è½½å¿…è¦æ•°æ®
        loadData();
        
        console.log('System initialized successfully');
        
    } catch (error) {
        console.error('Error initializing system:', error);
    }
}

// æ¸…ç†æ—§çš„localStorageæ•°æ®
function clearOldData() {
    try {
        console.log('Cleaning up old localStorage data...');
        
        // æ¸…ç†æ—§çš„ä»·æ ¼è¡¨æ•°æ®
        if (localStorage.getItem('priceTable')) {
            const oldPriceData = JSON.parse(localStorage.getItem('priceTable'));
            console.log(`Found ${oldPriceData.length} old price entries, clearing...`);
            localStorage.removeItem('priceTable');
        }
        
        // æ¸…ç†æ—§çš„äº§å“æ•°æ®
        if (localStorage.getItem('products')) {
            const oldProducts = JSON.parse(localStorage.getItem('products'));
            console.log(`Found ${oldProducts.length} old product entries, clearing...`);
            localStorage.removeItem('products');
        }
        
        // æ¸…ç†æ—§çš„ä»·ç›®è¡¨æ˜¾ç¤º
        const priceTableDisplay = document.getElementById('priceTableDisplay');
        if (priceTableDisplay) {
            priceTableDisplay.innerHTML = `
                <div class="info-message" style="text-align: center; padding: 20px; color: #666;">
                    <h4>ğŸ”„ æ•°æ®è¿ç§»å®Œæˆ</h4>
                    <p>æ—§çš„ä»·æ ¼æ•°æ®å·²è¿ç§»åˆ°SQLiteæ•°æ®åº“</p>
                    <p>è¯·ä½¿ç”¨"æ•°æ®æºé…ç½®"åŠŸèƒ½å¯¼å…¥æ–°çš„ä»·æ ¼æ•°æ®</p>
                    <p style="font-size: 12px; color: #999;">ç³»ç»Ÿå°†è‡ªåŠ¨æ¸…ç†æ—§çš„localStorageæ•°æ®</p>
                </div>
            `;
        }
        
        // æ¸…ç†å…¶ä»–å¯èƒ½å­˜åœ¨çš„æ—§æ•°æ®
        const oldDataKeys = [
            'priceReaderConfig',
            'oldPriceData',
            'tempPriceData'
        ];
        
        oldDataKeys.forEach(key => {
            if (localStorage.getItem(key)) {
                console.log(`Clearing old data key: ${key}`);
                localStorage.removeItem(key);
            }
        });
        
        console.log('Old data cleanup completed');
        
    } catch (error) {
        console.error('Error during old data cleanup:', error);
    }
}

// æ•°æ®åº“ç®¡ç†å‡½æ•°
async function initializeDatabase() {
    try {
        console.log('Initializing SQLite database...');
        
        // æ£€æŸ¥SQL.jsæ˜¯å¦å·²åŠ è½½
        if (typeof initSqlJs === 'undefined') {
            console.error('SQL.js library not found');
            return false;
        }
        
        // å°è¯•ä»IndexedDBåŠ è½½å·²ä¿å­˜çš„æ•°æ®åº“
        const databaseData = await loadDatabaseFromIndexedDB();
        
        if (databaseData) {
            console.log('Found saved database, loading...');
        } else {
            console.log('No saved database found, creating new one');
        }
        
        // åˆå§‹åŒ–SQL.js
        const SQL = await initSqlJs({
            locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
        });
        
        // åˆ›å»ºæ•°æ®åº“å®ä¾‹
        if (databaseData) {
            db = new SQL.Database(databaseData);
            console.log('Database loaded from saved data');
        } else {
            db = new SQL.Database();
            console.log('New database created');
        }
        
        // åˆ›å»ºè¡¨ç»“æ„
        createDatabaseTables();
        
        // æ£€æŸ¥æ˜¯å¦æœ‰ç°æœ‰æ•°æ®éœ€è¦å¯¼å…¥
        await checkAndImportExistingData();
        
        console.log('Database initialized successfully');
        return true;
        
    } catch (error) {
        console.error('Error initializing database:', error);
        return false;
    }
}

// åˆ›å»ºæ•°æ®åº“è¡¨ç»“æ„
function createDatabaseTables() {
    try {
        // åˆ›å»ºä»·ç›®è¡¨
        db.run(`
            CREATE TABLE IF NOT EXISTS price_table (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                category TEXT NOT NULL,
                system TEXT,
                code1 TEXT,
                code2 TEXT,
                width_min REAL NOT NULL,
                width_max REAL NOT NULL,
                height_min REAL NOT NULL,
                height_max REAL NOT NULL,
                price REAL NOT NULL,
                effective_date DATE,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);
        
        // åˆ›å»ºæ•°æ®æºé…ç½®è¡¨
        db.run(`
            CREATE TABLE IF NOT EXISTS data_sources (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                type TEXT NOT NULL,
                path TEXT NOT NULL,
                last_sync DATETIME,
                is_active BOOLEAN DEFAULT 1
            )
        `);
        
        // åˆ›å»ºç´¢å¼•ä»¥æé«˜æŸ¥è¯¢æ€§èƒ½
        db.run('CREATE INDEX IF NOT EXISTS idx_category ON price_table(category)');
        db.run('CREATE INDEX IF NOT EXISTS idx_dimensions ON price_table(width_min, width_max, height_min, height_max)');
        db.run('CREATE INDEX IF NOT EXISTS idx_price ON price_table(price)');
        
        console.log('Database tables created successfully');
        
    } catch (error) {
        console.error('Error creating database tables:', error);
    }
}

// æ£€æŸ¥å¹¶å¯¼å…¥ç°æœ‰æ•°æ®
async function checkAndImportExistingData() {
    try {
        // æ£€æŸ¥localStorageä¸­æ˜¯å¦æœ‰ä»·ç›®è¡¨æ•°æ®
        const existingPriceTable = localStorage.getItem('priceTable');
        if (existingPriceTable) {
            const priceData = JSON.parse(existingPriceTable);
            if (priceData.length > 0) {
                console.log('Importing existing price data to database...');
                await importPriceDataToDatabase(priceData);
                
                // å¯¼å…¥æˆåŠŸåæ¸…é™¤localStorageä¸­çš„æ•°æ®
                localStorage.removeItem('priceTable');
                console.log('Existing price data imported to database and cleared from localStorage');
            }
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰é…ç½®çš„æ•°æ®æºæ–‡ä»¶éœ€è¦å¯¼å…¥
        if (dataSourceConfig.currentSource === 'local' && dataSourceConfig.localPath) {
            await importDataFromFile(dataSourceConfig.localPath);
        }
        
    } catch (error) {
        console.error('Error importing existing data:', error);
    }
}

// å°†ä»·ç›®è¡¨æ•°æ®å¯¼å…¥æ•°æ®åº“
async function importPriceDataToDatabase(priceData) {
    try {
        if (!db) {
            console.error('Database not initialized');
            return false;
        }
        
        // å¼€å§‹äº‹åŠ¡
        db.run('BEGIN TRANSACTION');
        
        // æ¸…ç©ºç°æœ‰æ•°æ®
        db.run('DELETE FROM price_table');
        
        // æ’å…¥æ–°æ•°æ®
        const stmt = db.prepare(`
            INSERT INTO price_table (category, system, code1, code2, width_min, width_max, height_min, height_max, price)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `);
        
        let successCount = 0;
        priceData.forEach(item => {
            try {
                if (item.category && item.width_min && item.width_max && item.height_min && item.height_max && item.price) {
                    stmt.run([
                        item.category,
                        item.system || '',
                        item.code1 || '',
                        item.code2 || '',
                        item.width_min,
                        item.width_max,
                        item.height_min,
                        item.height_max,
                        item.price
                    ]);
                    successCount++;
                } else {
                    console.warn('Skipping invalid item:', item);
                }
            } catch (rowError) {
                console.warn('Error inserting row:', rowError, item);
            }
        });
        
        stmt.free();
        
        // æäº¤äº‹åŠ¡
        db.run('COMMIT');
        
        console.log(`Database import summary:`);
        console.log(`   - Total items to import: ${priceData.length}`);
        console.log(`   - Successfully imported: ${successCount}`);
        console.log(`   - Failed to import: ${priceData.length - successCount}`);
        
        // ä¿å­˜æ•°æ®åº“åˆ°localStorage
        saveDatabaseToIndexedDB();
        
        console.log(`Successfully imported ${successCount} price entries to database`);
        return true;
        
    } catch (error) {
        console.error('Error importing price data to database:', error);
        // å›æ»šäº‹åŠ¡
        if (db) {
            db.run('ROLLBACK');
        }
        return false;
    }
}

// ä¿å­˜æ•°æ®åº“åˆ°IndexedDB
async function saveDatabaseToIndexedDB() {
    try {
        if (!db) {
            console.warn('Database not initialized, cannot save');
            return;
        }
        
        // å¯¼å‡ºæ•°æ®åº“
        const databaseData = db.export();
        
        // å‹ç¼©æ•°æ®åº“æ•°æ®ï¼ˆä½¿ç”¨ç®€å•çš„å‹ç¼©ç­–ç•¥ï¼‰
        const compressedData = compressDatabaseData(databaseData);
        
        console.log(`Database size: ${databaseData.length} bytes, Compressed: ${compressedData.length} bytes`);
        
        // ä½¿ç”¨IndexedDBä¿å­˜
        const dbName = 'PromoteAppDB';
        const storeName = 'sqliteDatabase';
        const version = 1;
        
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(dbName, version);
            
            request.onerror = () => {
                console.error('Failed to open IndexedDB:', request.error);
                reject(request.error);
            };
            
            request.onsuccess = () => {
                const db = request.result;
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                
                const saveRequest = store.put(compressedData, 'main');
                
                saveRequest.onsuccess = () => {
                    console.log('Database saved to IndexedDB successfully');
                    resolve();
                };
                
                saveRequest.onerror = () => {
                    console.error('Failed to save database to IndexedDB:', saveRequest.error);
                    reject(saveRequest.error);
                };
                
                transaction.oncomplete = () => {
                    db.close();
                };
            };
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(storeName)) {
                    db.createObjectStore(storeName);
                }
            };
        });
        
    } catch (error) {
        console.error('Error saving database to IndexedDB:', error);
        throw error;
    }
}

// å‹ç¼©æ•°æ®åº“æ•°æ®
function compressDatabaseData(data) {
    try {
        // ä½¿ç”¨ç®€å•çš„å‹ç¼©ç­–ç•¥ï¼šå»é™¤é‡å¤å­—èŠ‚æ¨¡å¼
        const compressed = [];
        let i = 0;
        
        while (i < data.length) {
            let count = 1;
            const currentByte = data[i];
            
            // è®¡ç®—è¿ç»­ç›¸åŒå­—èŠ‚çš„æ•°é‡
            while (i + count < data.length && data[i + count] === currentByte && count < 255) {
                count++;
            }
            
            if (count > 3) {
                // ä½¿ç”¨RLEå‹ç¼©
                compressed.push(0, count, currentByte);
                i += count;
            } else {
                compressed.push(currentByte);
                i++;
            }
        }
        
        return new Uint8Array(compressed);
        
    } catch (error) {
        console.error('Error compressing database data:', error);
        return data; // å¦‚æœå‹ç¼©å¤±è´¥ï¼Œè¿”å›åŸå§‹æ•°æ®
    }
}

// è§£å‹ç¼©æ•°æ®åº“æ•°æ®
function decompressDatabaseData(compressedData) {
    try {
        const decompressed = [];
        let i = 0;
        
        while (i < compressedData.length) {
            if (compressedData[i] === 0 && i + 2 < compressedData.length) {
                // RLEè§£å‹ç¼©
                const count = compressedData[i + 1];
                const byte = compressedData[i + 2];
                
                for (let j = 0; j < count; j++) {
                    decompressed.push(byte);
                }
                
                i += 3;
            } else {
                decompressed.push(compressedData[i]);
                i++;
            }
        }
        
        return new Uint8Array(decompressed);
        
    } catch (error) {
        console.error('Error decompressing database data:', error);
        return compressedData; // å¦‚æœè§£å‹ç¼©å¤±è´¥ï¼Œè¿”å›åŸå§‹æ•°æ®
    }
}

// ä»IndexedDBåŠ è½½æ•°æ®åº“
async function loadDatabaseFromIndexedDB() {
    try {
        const dbName = 'PromoteAppDB';
        const storeName = 'sqliteDatabase';
        const version = 1;
        
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(dbName, version);
            
            request.onerror = () => {
                console.log('IndexedDB not available, creating new database');
                resolve(null);
            };
            
            request.onsuccess = () => {
                const db = request.result;
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                
                const loadRequest = store.get('main');
                
                loadRequest.onsuccess = () => {
                    if (loadRequest.result) {
                        console.log('Database loaded from IndexedDB successfully');
                        // è§£å‹ç¼©æ•°æ®
                        const decompressedData = decompressDatabaseData(loadRequest.result);
                        resolve(decompressedData);
                    } else {
                        console.log('No saved database found in IndexedDB');
                        resolve(null);
                    }
                };
                
                loadRequest.onerror = () => {
                    console.error('Failed to load database from IndexedDB:', loadRequest.error);
                    resolve(null);
                };
                
                transaction.oncomplete = () => {
                    db.close();
                };
            };
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(storeName)) {
                    db.createObjectStore(storeName);
                }
            };
        });
        
    } catch (error) {
        console.error('Error loading database from IndexedDB:', error);
        return null;
    }
}

// æ›´æ–°æŠ¥ä»·å•æ±‡æ€»
function updateQuotationSummary() {
    try {
        let subtotal = 0;
        
        document.querySelectorAll('.product-item').forEach(item => {
            const subtotalInput = item.querySelectorAll('input')[4];  // æ€»ä»·è¾“å…¥æ¡†
            if (subtotalInput && subtotalInput.value && subtotalInput.value !== '$0.00' && subtotalInput.value !== '') {
                // æå–æ•°å­—éƒ¨åˆ†
                const subtotalValue = parseFloat(subtotalInput.value.replace(/[$,]/g, ''));
                if (!isNaN(subtotalValue) && subtotalValue > 0) {
                    subtotal += subtotalValue;
                }
            }
        });
        
        const taxRateElement = safeGetElement('taxRate');
        const shippingFeeElement = safeGetElement('shippingFee');
        const subtotalElement = safeGetElement('subtotal');
        const taxAmountElement = safeGetElement('taxAmount');
        const totalAmountElement = safeGetElement('totalAmount');
        
        if (!taxRateElement || !shippingFeeElement || !subtotalElement || !taxAmountElement || !totalAmountElement) {
            console.warn('Some summary elements not found');
            return;
        }
        
        const taxRate = parseFloat(taxRateElement.value) || 0;
        const shippingFee = parseFloat(shippingFeeElement.value) || 0;
        
        const taxAmount = subtotal * (taxRate / 100);
        const totalAmount = subtotal + taxAmount + shippingFee;
        
        subtotalElement.textContent = formatCurrency(subtotal);
        taxAmountElement.textContent = formatCurrency(taxAmount);
        totalAmountElement.textContent = formatCurrency(totalAmount);
        
    } catch (error) {
        console.error('Error updating quotation summary:', error);
    }
}

// åŠ è½½æ•°æ®
function loadData() {
    try {
        // åŠ è½½ç”¨æˆ·æ•°æ®
        users = JSON.parse(localStorage.getItem('users') || '[]');
        
        // åŠ è½½ç³»ç»Ÿè®¾ç½®
        systemSettings = JSON.parse(localStorage.getItem('systemSettings') || '{}');
        
        // åŠ è½½æ•°æ®æºé…ç½®
        if (localStorage.getItem('dataSourceConfig')) {
            dataSourceConfig = JSON.parse(localStorage.getItem('dataSourceConfig'));
        }
        
        console.log('Data loaded - Users:', users.length, 'entries');
        console.log('Data loaded - System Settings:', Object.keys(systemSettings).length, 'entries');
        
    } catch (error) {
        console.error('Error loading data:', error);
    }
}

// ä»æ–‡ä»¶å¯¼å…¥æ•°æ®
async function importDataFromFile(filePath) {
    try {
        console.log('Importing data from file:', filePath);
        
        // è¿™é‡Œæ˜¯ä¸€ä¸ªå ä½ç¬¦å®ç°
        // å®é™…çš„æ–‡ä»¶å¯¼å…¥é€»è¾‘åœ¨processImportFileAsyncä¸­
        console.log('File import initiated from path:', filePath);
        
    } catch (error) {
        console.error('Error importing data from file:', error);
    }
}

// ç”¨æˆ·ç™»å½•
function login() {
    try {
        const username = document.getElementById('username').value;
        const password = document.getElementById('password').value;
        
        if (!username || !password) {
            alert('è¯·è¾“å…¥ç”¨æˆ·åå’Œå¯†ç ');
            return;
        }
        
        // ç¡®ä¿ç”¨æˆ·æ•°æ®å·²åŠ è½½
        if (!users || users.length === 0) {
            users = JSON.parse(localStorage.getItem('users') || '[]');
        }
        
        console.log('Available users:', users);
        console.log('Attempting login with:', username, password);
        
        const user = users.find(u => u.username === username && u.password === password);
        
        if (user) {
            console.log('Login successful:', user);
            currentUser = user;
            localStorage.setItem('currentUser', JSON.stringify(user));
            
            if (user.role === 'admin') {
                showAdminBackend();
            } else {
                showSalesFrontend();
            }
        } else {
            console.log('Login failed - no matching user found');
            alert('ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯');
        }
        
    } catch (error) {
        console.error('Error during login:', error);
        alert('ç™»å½•è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯');
    }
}

// æ˜¾ç¤ºç™»å½•é¡µé¢
function showLoginPage() {
    try {
        document.getElementById('loginPage').style.display = 'flex';
        document.getElementById('salesFrontend').style.display = 'none';
        document.getElementById('adminBackend').style.display = 'none';
    } catch (error) {
        console.error('Error showing login page:', error);
    }
}

// æ˜¾ç¤ºé”€å”®å‘˜å‰å°
function showSalesFrontend() {
    try {
        document.getElementById('loginPage').style.display = 'none';
        document.getElementById('salesFrontend').style.display = 'block';
        document.getElementById('adminBackend').style.display = 'none';
        
        const currentUserElement = document.getElementById('currentUser');
        if (currentUserElement) {
            currentUserElement.textContent = `${currentUser.realName} (${currentUser.username})`;
        }
        
        // åˆå§‹åŒ–å¿«é€ŸæŸ¥ä»·
        initializePricingRows();
        
    } catch (error) {
        console.error('Error showing sales frontend:', error);
    }
}

// æ˜¾ç¤ºç®¡ç†å‘˜åå°
function showAdminBackend() {
    try {
        document.getElementById('loginPage').style.display = 'none';
        document.getElementById('salesFrontend').style.display = 'none';
        document.getElementById('adminBackend').style.display = 'block';
        
        const adminUserElement = document.getElementById('adminUser');
        if (adminUserElement) {
            adminUserElement.textContent = `${currentUser.realName} (${currentUser.username})`;
        }
        
        // åŠ è½½ç®¡ç†æ•°æ®
        loadAdminData();
        
    } catch (error) {
        console.error('Error showing admin backend:', error);
    }
}

// æ ¼å¼åŒ–è´§å¸
function formatCurrency(amount) {
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD'
    }).format(amount);
}

// åŠ è½½ç®¡ç†æ•°æ®
function loadAdminData() {
    try {
        console.log('Loading admin data...');
        
        // è¿™é‡Œå¯ä»¥æ·»åŠ åŠ è½½ç®¡ç†å‘˜ç‰¹å®šæ•°æ®çš„é€»è¾‘
        // ä¾‹å¦‚ï¼šåŠ è½½æ¨å¹¿è®¾è®¡ã€ç”¨æˆ·ç®¡ç†ã€æŠ¥ä»·ç®¡ç†ç­‰æ•°æ®
        
        console.log('Admin data loaded successfully');
        
    } catch (error) {
        console.error('Error loading admin data:', error);
    }
}

// åˆå§‹åŒ–å¿«é€ŸæŸ¥ä»·è¡Œ
function initializePricingRows() {
    try {
        const container = document.getElementById('pricingRows');
        if (!container) {
            console.log('pricingRows container not found, skipping initialization');
            return;
        }
        
        container.innerHTML = '';
        addPricingRow(); // æ·»åŠ ç¬¬ä¸€è¡Œ
        
    } catch (error) {
        console.error('Error initializing pricing rows:', error);
    }
}

// æ·»åŠ æŸ¥ä»·è¡Œ
function addPricingRow() {
    try {
        const container = document.getElementById('pricingRows');
        if (!container) {
            console.log('pricingRows container not found, skipping addPricingRow');
            return;
        }
        
        const rowId = Date.now();
        const rowNumber = container.children.length + 1;
        
        // ä»æ•°æ®åº“è·å–ç±»åˆ«é€‰é¡¹
        const categories = db ? getAllCategoriesFromDatabase() : [];
        
        const rowHtml = `
            <div class="pricing-row" id="pricing-row-${rowId}">
                <div class="pricing-row-content">
                    <div class="form-group">
                        <label>No.:</label>
                        <input type="text" value="${rowNumber}" readonly style="text-align: center; background: #f8f9fa;">
                    </div>
                    <div class="form-group">
                        <label>Category:</label>
                        <select onchange="updatePricingRow(${rowId})">
                            <option value="">Select Category</option>
                            ${categories.map(cat => `<option value="${cat}">${cat}</option>`).join('')}
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Width:</label>
                        <input type="number" step="0.01" placeholder="Width" onchange="updatePricingRow(${rowId})">
                    </div>
                    <div class="form-group">
                        <label>Width Unit:</label>
                        <select onchange="updatePricingRow(${rowId})">
                            <option value="cm">cm</option>
                            <option value="in">in</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Height:</label>
                        <input type="number" step="0.01" placeholder="Height" onchange="updatePricingRow(${rowId})">
                    </div>
                    <div class="form-group">
                        <label>Height Unit:</label>
                        <select onchange="updatePricingRows">
                            <option value="cm">cm</option>
                            <option value="in">in</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Quantity:</label>
                        <input type="number" min="1" value="1" onchange="updatePricingRow(${rowId})">
                    </div>
                    <div class="form-group">
                        <label>Unit Price:</label>
                        <input type="text" readonly class="currency">
                    </div>
                    <div class="form-group">
                        <label>Subtotal:</label>
                        <input type="text" readonly class="currency">
                    </div>
                    <div class="form-group">
                        <label>Total:</label>
                        <input type="text" readonly class="currency">
                    </div>
                    <div class="form-group">
                        <button onclick="removePricingRow(${rowId})" class="btn-danger">Remove</button>
                    </div>
                </div>
            </div>
        `;
        
        container.insertAdjacentHTML('beforeend', rowHtml);
        
    } catch (error) {
        console.error('Error adding pricing row:', error);
    }
}

// æ›´æ–°æŸ¥ä»·è¡Œ
function updatePricingRow(rowId) {
    try {
        const row = document.getElementById(`pricing-row-${rowId}`);
        if (!row) return;
        
        // è¿™é‡Œå¯ä»¥æ·»åŠ ä»·æ ¼æŸ¥è¯¢é€»è¾‘
        console.log(`Updating pricing row ${rowId}`);
        
    } catch (error) {
        console.error('Error updating pricing row:', error);
    }
}

// ç§»é™¤æŸ¥ä»·è¡Œ
function removePricingRow(rowId) {
    try {
        const row = document.getElementById(`pricing-row-${rowId}`);
        if (row) {
            row.remove();
        }
    } catch (error) {
        console.error('Error removing pricing row:', error);
    }
}

// åˆ‡æ¢æ•°æ®åº“é…ç½®æ˜¾ç¤º
function toggleDatabaseConfig() {
    try {
        const dbType = document.getElementById('dbType').value;
        const apiUrlGroup = document.getElementById('apiUrlGroup');
        const apiAuthGroup = document.getElementById('apiAuthGroup');
        
        if (apiUrlGroup && apiAuthGroup) {
            if (dbType === 'api') {
                apiUrlGroup.style.display = 'block';
                apiAuthGroup.style.display = 'block';
            } else {
                apiUrlGroup.style.display = 'none';
                apiAuthGroup.style.display = 'none';
            }
        }
        
    } catch (error) {
        console.error('Error toggling database config:', error);
    }
}

// åˆ‡æ¢æ•°æ®æºé…ç½®æ˜¾ç¤º
function toggleDataSourceConfig() {
    try {
        const dataSourceType = document.getElementById('dataSourceType').value;
        const localFileConfig = document.getElementById('localFileConfig');
        const remoteServerConfig = document.getElementById('remoteServerConfig');
        
        if (localFileConfig && remoteServerConfig) {
            if (dataSourceType === 'local') {
                localFileConfig.style.display = 'block';
                remoteServerConfig.style.display = 'none';
            } else {
                localFileConfig.style.display = 'none';
                remoteServerConfig.style.display = 'block';
            }
        }
        
    } catch (error) {
        console.error('Error toggling data source config:', error);
    }
}

// ä¿å­˜æ•°æ®åº“é…ç½®
function saveDatabaseConfig() {
    try {
        const dbType = document.getElementById('dbType').value;
        const apiBaseUrl = document.getElementById('apiBaseUrl').value;
        const apiKey = document.getElementById('apiKey').value;
        
        const config = {
            type: dbType,
            apiBase: apiBaseUrl,
            apiKey: apiKey
        };
        
        localStorage.setItem('dbConfig', JSON.stringify(config));
        console.log('Database configuration saved successfully');
        alert('æ•°æ®åº“é…ç½®ä¿å­˜æˆåŠŸï¼');
        
    } catch (error) {
        console.error('Error saving database config:', error);
        alert('ä¿å­˜æ•°æ®åº“é…ç½®æ—¶å‘ç”Ÿé”™è¯¯');
    }
}

// æµ‹è¯•æ•°æ®åº“è¿æ¥
function testDatabaseConnection() {
    try {
        const dbType = document.getElementById('dbType').value;
        
        if (dbType === 'sqlite') {
            if (db) {
                alert('SQLiteæ•°æ®åº“è¿æ¥æ­£å¸¸ï¼');
            } else {
                alert('SQLiteæ•°æ®åº“æœªåˆå§‹åŒ–ï¼');
            }
        } else if (dbType === 'api') {
            const apiBaseUrl = document.getElementById('apiBaseUrl').value;
            if (!apiBaseUrl) {
                alert('è¯·è¾“å…¥APIåŸºç¡€URLï¼');
                return;
            }
            
            // è¿™é‡Œå¯ä»¥æ·»åŠ å®é™…çš„APIè¿æ¥æµ‹è¯•
            alert('APIè¿æ¥æµ‹è¯•åŠŸèƒ½å¾…å®ç°');
            
        } else {
            alert('æœªçŸ¥çš„æ•°æ®åº“ç±»å‹ï¼');
        }
        
    } catch (error) {
        console.error('Error testing database connection:', error);
        alert('æµ‹è¯•æ•°æ®åº“è¿æ¥æ—¶å‘ç”Ÿé”™è¯¯');
    }
}

// ä¿å­˜æ•°æ®æºé…ç½®
function saveDataSourceConfig() {
    try {
        const dataSourceType = document.getElementById('dataSourceType');
        const mainFileInput = document.getElementById('mainFileInput');
        const remoteUrl = document.getElementById('remoteUrl');
        
        if (!dataSourceType) {
            alert('æ•°æ®æºç±»å‹é€‰æ‹©å™¨æœªæ‰¾åˆ°ï¼');
            return;
        }
        
        let localPath = '';
        if (mainFileInput && mainFileInput.files.length > 0) {
            localPath = mainFileInput.files[0].name;
        }
        
        const config = {
            currentSource: dataSourceType.value,
            localPath: localPath,
            remoteUrl: remoteUrl ? remoteUrl.value : '',
            lastSync: new Date().toISOString()
        };
        
        localStorage.setItem('dataSourceConfig', JSON.stringify(config));
        dataSourceConfig = config;
        
        console.log('Data source configuration saved successfully');
        alert('æ•°æ®æºé…ç½®ä¿å­˜æˆåŠŸï¼');
        
    } catch (error) {
        console.error('Error saving data source config:', error);
        alert('ä¿å­˜æ•°æ®æºé…ç½®æ—¶å‘ç”Ÿé”™è¯¯');
    }
}

// ä»æ•°æ®æºå¯¼å…¥æ•°æ®
async function importDataFromSource() {
    try {
        const dataSourceType = document.getElementById('dataSourceType').value;
        
        if (dataSourceType === 'local') {
            const fileInput = document.getElementById('mainFileInput');
            if (fileInput && fileInput.files.length > 0) {
                await processImportFileAsync(fileInput.files[0]);
            } else {
                alert('è¯·å…ˆé€‰æ‹©è¦å¯¼å…¥çš„æ–‡ä»¶ï¼');
            }
        } else if (dataSourceType === 'remote') {
            const remoteUrl = document.getElementById('remoteUrl').value;
            if (!remoteUrl) {
                alert('è¯·è¾“å…¥è¿œç¨‹æœåŠ¡å™¨URLï¼');
                return;
            }
            
            // è¿™é‡Œå¯ä»¥æ·»åŠ è¿œç¨‹æ•°æ®å¯¼å…¥é€»è¾‘
            alert('è¿œç¨‹æ•°æ®å¯¼å…¥åŠŸèƒ½å¾…å®ç°');
            
        } else {
            alert('è¯·é€‰æ‹©æ•°æ®æºç±»å‹ï¼');
        }
        
    } catch (error) {
        console.error('Error importing data from source:', error);
        alert('å¯¼å…¥æ•°æ®æ—¶å‘ç”Ÿé”™è¯¯');
    }
}

// å¤„ç†æ–‡ä»¶é€‰æ‹©
function handleFileSelection(fileInput) {
    try {
        const file = fileInput.files[0];
        if (file) {
            displayFileInfo(file);
            autoSetFileFormat(file);
            
            console.log('File selected:', file.name, 'Size:', file.size, 'bytes');
        }
    } catch (error) {
        console.error('Error handling file selection:', error);
    }
}

// æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯
function displayFileInfo(file) {
    try {
        const fileInfo = document.getElementById('fileInfo');
        if (fileInfo) {
            fileInfo.innerHTML = `
                <p><strong>æ–‡ä»¶å:</strong> ${file.name}</p>
                <p><strong>å¤§å°:</strong> ${formatFileSize(file.size)}</p>
                <p><strong>ç±»å‹:</strong> ${file.type || 'æœªçŸ¥'}</p>
            `;
            fileInfo.style.display = 'block';
        }
    } catch (error) {
        console.error('Error displaying file info:', error);
    }
}

// è‡ªåŠ¨è®¾ç½®æ–‡ä»¶æ ¼å¼
function autoSetFileFormat(file) {
    try {
        const fileFormat = document.getElementById('fileFormat');
        if (fileFormat) {
            const extension = file.name.split('.').pop().toLowerCase();
            if (extension === 'xlsx' || extension === 'xls') {
                fileFormat.value = 'excel';
            } else if (extension === 'csv') {
                fileFormat.value = 'csv';
            }
        }
    } catch (error) {
        console.error('Error auto-setting file format:', error);
    }
}

// æ¸…é™¤æ–‡ä»¶é€‰æ‹©
function clearFileSelection() {
    try {
        const fileInput = document.getElementById('mainFileInput');
        const fileInfo = document.getElementById('fileInfo');
        
        if (fileInput) fileInput.value = '';
        if (fileInfo) fileInfo.style.display = 'none';
        
        console.log('File selection cleared');
    } catch (error) {
        console.error('Error clearing file selection:', error);
    }
}

// æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
function formatFileSize(bytes) {
    try {
        if (bytes === 0) return '0 Bytes';
        
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        
    } catch (error) {
        console.error('Error formatting file size:', error);
        return bytes + ' bytes';
    }
}
